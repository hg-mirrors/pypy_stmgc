==================================================
Details of the interactions between STM and the GC
==================================================

In this document we say "high-level object" to mean an object from the
point of the user of the library, as opposed to an "object copy", which
is what occupies the space of one allocated piece of memory.  One
high-level object can exist in several copies simultaneously.  This
concept of "copy" should not be confused with a "revision", which stands
for a globally consistent copy of all objects.  One revision is the
result of one transaction.  A program usually has one revision per
thread in progress, plus any number of older committed revisions.  The
committed revisions are globally ordered.

The object copies exist in one of three main states: they can be
"private", "protected" or "public".  A copy is private when it belongs
to the transaction in progress.  When that transaction commits, it
becomes protected, and remains so as long as it is accessed only by the
same thread.  A copy becomes public only when another thread requests
access to it (or, more precisely, "steals" access to it).  Once public,
a copy is immutable in memory.

From the point of view of the generational GC, each copy is either young
or old.  All new copies are allocated young.  They become old at the
next minor collection.  In the common case, copies are allocated in the
nursery, and during the next minor collection, if they survive, they are
moved outside.  The nursery contains only young copies, but a few copies
outside might be young too (e.g. copies of objects too large for the
nursery).  (In fact we found out in PyPy that it's a good idea to create
objects young even if they are outside the nursery; otherwise, a program
that creates a lot of medium-sized objects will quickly exhaust the
memory and trigger a lot of major collections.)  For the rest of this
document we'll ignore young copies outside the nursery.

An object that was never seen by a different thread has got at most two
copies: the first, protected, is the copy at the latest committed
revision; and the other, private, is the current copy.  If the
transaction aborts we can forget the private copy and reuse the previous
protected copy.  If the transaction commits we forget the previous
protected copy instead; then the private copy becomes protected, like
*all* private copies at this point.  If the object is modified again in
the near future, we reuse the memory that was occupied by the previous
copy to store the next private copy.  As a result, each of these two
spaces in memory can be young or old.  If an object is no longer
modified for long enough, the next (minor or major) GC will free one of
the two spaces it uses.

The way to share data between threads goes via prebuilt objects, which
are always public: it is their existence that gives the starting point
for threads to see each other's objects.  This involves three different
steps.

1. A thread tries to write to a public object.  This is done by
allocating a fresh private copy of the public object.  Then writes go to
the private copy.  If the transaction commits, the private copy becomes
protected, and the public object is made to point to it (with
multithread care).  From now on, any access to the public object from
the same thread will work on the protected object or its future private
copy.  Any access from a different thread will trigger "stealing", as
explained next.

2. When we are running a thread, it may try to access a public object
but find that another thread (the "foreign thread") has committed
changes to it .  Then we "steal" the object.  It is a read-only
operation performed by peeking on the foreign thread's data.  The
operation involves making a duplicate of the original copy, if it was in
the foreign thread's nursery (so that no thread ever reads another
thread's nursery, outside of "stealing").  The stolen copy, or the
original protected copy if it was not in the nursery, is then marked as
public.  From now on nobody is allowed to change (or free) the content
of this copy, and it becomes the current public copy.  These public
copies accumulate: every time the same object is stolen by a different
thread, a new public copy is made (so that unrelated threads don't have
to worry about existing public copies being updated).  (This chain of
objects is freed at the next major GC, which is a stop-the-world
operation.)

3. A subtle but important point about making a public copy is about all
the references stored in the object: if they point to other protected
objects, then we cannot simply keep them as they are in the public copy.
In that case, we have to replace these references with pointers to
public "stubs".  A stub consists of only the header of the object.  It
is set up in the same way as in point 1 above: it plays the role of an
"older" public copy of a protected object (although it is not actually
older of course).  If "we", the thread that just stole the object, then
try to follow one of the references, we will access one of these stubs,
and go back to point 2: stealing the target object's protected copy.


Read/Write Barriers
-------------------

This design is made to optimize the hopefully common case: objects we
handle are mostly private or protected, or if they are public, they are
mostly read-only.  We can design in consequence the following three
points:

1. the extra data stored in the objects (GC flags, and one extra word
called `h_revision`).

2. the other "off-line" data stored in thread-local data.

3. the read/write barriers.

Point 3 is essential for performance: we want most importantly a read
barrier that doesn't trigger for the cases described above.  There are
basically three cases:

1. read_barrier(P) = P   [if P is directly a non-modified copy]

2. read_barrier(P) = P->h_revision   [protected copy -> private copy]

3. all other more complex cases, handled by a call.

It is possible to compress the first two cases into C code that GCC
compiles into a total of two or three assembler instructions, using a
conditional move.  (Still, it is unclear so far if case 2 is worth
inlining at every read barrier site, or should be left to the call.)

The case of the write barrier is similar, but differs in the check for
case 1: this case is reduced to only private objects.  This could be
done simply by checking a different GC flags.

Note that this design relies on the following property: in a given copy
of an object which was committed at revision N, all pointers points to
copies of objects which were committed at or before revision N.  This
property is true by construction, but we must be careful not to break it
by "optimizing" the content of a copy.  In particular the GC, during
both minor and major collections, has to preserve this property.  


The extendable timestamp model
------------------------------

A public object copy is either up-to-date (no more recent committed
copy) or outdated.  The public copies need to have globally consistent
revision numbers (produced at commit time).  If there are several copies
of the same object, we only need to store the revision number of the
most recent one.  The previous copies are simply outdated and need
instead to store a pointer to a more recent copy.

The important property is that committed transactions must be
"linearized": when we look at them a posteriori, it must be as if they
ran serially in some order.  This includes the reads done during the
transaction: they must return data from the most recently committed copy
of the objects (in the same order).  This is done with a shared global
variable, the "global time", that gives the most recently committed
revision number.  Each transaction in progress stores a temporary
"starting time".  It is initially set to the current global time.  If,
at the end of the transaction, all objects read during the transaction
have a revision not greater than this starting time, then we have no
"read-write" conflict (i.e. reads of an object that another thread has
modified; there are also "write-write" conflicts).  An improvement over
this basic model is that if, during the transaction, we are about to
read a new object and detect a read-write conflict, we can try to
"extend" the starting time to the value that is now stored in the global
time variable.  If none of the objects that we have read previously have
been modified in the interval, then the transaction would have given the
same results if it had started at the new time.

The model described above is known in the literature as the "extendable
timestamp" model.  We apply it for public object.  It can however be
tweaked for protected objects.


Pointers and revision numbers on protected objects
--------------------------------------------------

In traditional transactional systems, we have a special case to speed up
transactions that don't do any write; but that seems too restricted to
be useful in PyPy.  Instead, we can have a special case for transactions
that don't write to any *public* object.  Our assumption is that
transactions can be anywhere from very small to very large; the small
ones are unlikely to change any object that has been seen by another
thread.  Moreover the previous transaction in the same thread is
unlikely to have got one of its objects stolen.

To cover this case more efficiently, we assign in theory to each
committed transaction a pair of numbers.  The first one is the regular
global time at which the transaction was committed.  The second one is a
thread-local number (never actually made explicit in the code).  The
global order of the committed transactions is given by the ordering of
these 2-tuples.

A commit with writes to public objects works as described above; it
gives the transaction the number `(global_time, 0)`, and atomically
increments `global_time`.

A commit with no write to any public object produces the number
`(start_time, N+1)`, provided that we didn't have any object stolen
since `start_time`.  This condition is enough to guarantee that it is ok
to linearize the transaction at `(start_time, N+1)` even though other
threads might already have produced transactions linearized at some
greater time.  Indeed, the fact that no object of ours was stolen
means that no other thread's transaction depends on any object we're
about to commit.
