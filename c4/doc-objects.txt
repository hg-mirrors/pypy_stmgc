
Design goal
-----------

stm_read_barrier(P) -> P: the read barrier (containing a call in the
slow path) can be applied on a pointer to an object, and returns a
possibly different pointer.  Afterwards, any reads from the object can
be done normally (using the returned pointer).

stm_write_barrier(P) -> P: the same for writes (actually read/write mode).

The returned pointers are valid until a potential transaction break ---
with the exception that the result of stm_read_barrier() will be
invalidated by a stm_write_barrier() done on the same object.

This means we must not modify an object in-place from thread A when
thread B might be reading from it!  It is the basis for the design
outlined in the sequel, in which "protected" objects are seen by only
one thread, whereas "public" objects are seen by all threads.



Object copies state transitions (changes of state of the *same* copy)
---------------------------------------------------------------------



  Private freshly created
             \                Private, with backup
              \                ^  /
        commit \              /  / commit
                \     modify /  /
                 \          /  /
                  V        /  V
                   Protected
                  ^        \         Backup of a private
                 /          \         /
         commit /            \ steal /
               /              \     /
              /                V   V
    Private copy of           Public
    a public obj



Kind of object copy                                    h_revision
-------------------------------------------------------------------

Private objects:
- freshly created                                         PRN
- converted from a protected obj                     ptr to backup
- private copy of a public obj                            PRN

Protected objects:
- converted from fresh private obj                     (old PRN)
- converted from a private obj                            GT

Backup copy:
- backup copy of a private obj                    original h_revision

Public objects:
- prebuilt object, never modified                          1
- other public object, never modified                     GT
- outdated                             ptr to a more recent public copy

Public stubs (have also a ref to one thread):
- from stealing                            ptr (maybe to priv/prot) | 2


PRN = Private revision number (negative odd number)
GT = Global time (positive odd number)



Off-line data stored in the thread-local structure
--------------------------------------------------

- the PRN (private revision number): odd, negative, changes for every
  transaction that commits

- list private_from_protected = [private obj converted from protected]

- dict public_to_private = {public obj: private copy}

- list read_set containing the objects in the read set, with possibly
  some duplicates (but hopefully not too many)

- collection_lock: a thread-local lock that is acquired to change
  the status of private/protected objects



Kind of object copy          distinguishing feature
-------------------------------------------------------------------

Any private object           h_revision == PRN or GCFLAG_PRIVATE_FROM_PROTECTED
Private with a backup        GCFLAG_PRIVATE_FROM_PROTECTED
Backup copy                  GCFLAG_BACKUP_COPY (flag for debugging)
Any public object            GCFLAG_PUBLIC
Stubs                        GCFLAG_STUB (flag for debugging)

A public object that might \
be key in public_to_private  has additionally GCFLAG_PUBLIC_TO_PRIVATE



Read barrier
-----------------------------------------

Inline check: if h_revision == PRN or if P in read_barrier_cache,
              we don't call the slow path.
Slow path:

    if GCFLAG_PRIVATE_FROM_PROTECTED:

        check P->h_revision->h_revision: if a pointer, then it means
        the backup copy has been stolen into a public object and then
        modified by some other thread.  Abort.

        add P to 'read_barrier_cache' and return

    if GCFLAG_PUBLIC:

        follow the chained list of h_revision's as long as they are
        regular pointers

        if it ends with h_revision % 4 == 2:
            then we're in a stub

            if Thread is the current thread: follow P = h_revision - 2

            else: do stealing and restart the read barrier

        if we land on a P in read_barrier_cache:
            return P

        if P has GCFLAG_PUBLIC_TO_PRIVATE and is in 'public_to_private':
            return the private object

        if it ends with an odd revision number, check that it's older
        than start_time; extend the start timestamp if not

    add P to 'read_set'

    add P to 'read_barrier_cache' and return


It is unclear if it's better to stick all private objects into the
read_barrier_cache, or to extend the read barrier's inline code to also
check if h_revision == PRN (trade-off of polluting the cache with
private objects which might be a majority, vs. making the inline check
larger).

Stub objects are public, always outdated (with h_revision a pointer) and
contain only a header; additionally they have a thread descriptor that
tells to which thread the h_revision object is a protected/private
object of.

Stealing of an object copy L is done with the "collection lock" of the
target Thread.  The target would also acquire its own lock in when doing
some operations, like a minor collection or a write barrier on a
protected object, which can't occur in parallel with stealing.

Once we have the lock, stealing is:

    if the situation changed while we were waiting for the lock, return

    if L has GCFLAG_PRIVATE_FROM_PROTECTED:
        set L = L->h_revision (the backup copy)

    change L from protected to public, i.e. add GCFLAG_PUBLIC

    update the original P->h_revision to point directly to L



Write barrier
-----------------------------------------

The write barrier works for both STM purposes and for GC purposes.

Inline check: if h_revision == PRN or GCFLAG_PRIVATE_FROM_PROTECTED, we're done.
Slow path:

    R = read_barrier(P)     # always do a full read_barrier first

    if h_revision == PRN or GCFLAG_PRIVATE_FROM_PROTECTED:
        return R

    if GCFLAG_PUBLIC:

        add the flag GCFLAG_PUBLIC_TO_PRIVATE to R, if needed

        make a fresh private copy L of R, with h_revision == PRN

        add {R: L} in 'public_to_private'

        remove R from read_barrier_cache

        return L

    # else, R is a protected object
    with collection_lock:

        allocate a backup copy and copy the object into the backup copy

        change R->h_revision to be the backup copy
        
        set GCFLAG_PRIVATE_FROM_PROTECTED on R

        add R in 'private_from_protected'

        return R



Commit-time change of flags
---------------------------

(This occurs during commit, when we have got the collection_lock.)

public_to_private:

    write GT into the private object

    make a stub with h_revision = private object | 2

    after a CPU write barrier, make the public h_revision to point to the stub

private_from_protected:

    get the backup B from P->h_revision

    set P->h_revision to GT

    if B has GCFLAG_PUBLIC: it has been stolen

        if it has been modified: conflict, abort transaction

        B->h_revision = P

    else:
        possibly free B now, it's not used any more

