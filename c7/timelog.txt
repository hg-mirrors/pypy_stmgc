
Reports
=======

- self-abort:
    WRITE_WRITE_CONTENTION, INEVITABLE_CONTENTION:
       traceback in both threads, time lost by this thread
    WRITE_READ_CONTENTION:
       traceback pointing back to the write, time lost by this thread

- aborted by a different thread:
    WRITE_WRITE_CONTENTION:
       traceback in both threads, time lost by this thread
    WRITE_READ_CONTENTION:
       remote traceback pointing back to the write, time lost by this thread
       (no local traceback available to know where we've read the object from)
    INEVITABLE_CONTENTION:
       n/a

- self-pausing:
    same as self-abort, but reporting the time lost by pausing

- waiting for a free segment:
    - if we're waiting because of inevitability, report with a
      traceback and the time lost
    - if we're just waiting because of no free segment, don't report it,
      or maybe with only the total time lost and no traceback

- more internal reasons for cond_wait(), like synchronizing the threads,
  should all be resolved quickly and are unlikely worth a report


Internal Measurements
=====================

- use clock_gettime(CLOCK_MONOTONIC), it seems to be the fastest way
  (less than 5 times slower than a RDTSC instruction, which is itself
  not safe in the presence of threads migrating among CPUs)

- record only the highest-time entry.  The user of the library is
  responsible for getting and clearing it often enough if it wants
  more details.  [[ For example, it may want to maintain a heapq
  with several entries, but that's not the job of stmgc.  Moreover,
  if there are several aborts from what is logically the same starting
  place and which ends with the same traceback, we'd like to regroup them
  and report them only once with the number of consecutive occurrences
  and the total time; doing that before inserting the entries in the heapq
  list is needed, as otherwise if we have a lot of quick aborts they
  would all be lost as not contributing significant time individually.
  ]]


API of stmgc.h
==============

- the traceback reports are based on the user of the library pushing and
  popping stack entries to the current stack in every thread.

- we have a simple API to get and clear the traceback and reason of the
  single report with the highest recorded time, for the current thread.


Tracebacks
==========

Tracebacks are implemented as read-only objects in a linked list, each
one for one frame.  Each such object has a reference count, so that we can
internally record the current stack by taking a reference to the current
top-of-stack, and keep it entirely alive by increasing just this object's
reference count.  Some simple freelist should make this efficient for
the common case of objects freed shortly after being allocated.

We record one traceback pointer for every old object written during this
transaction.  It could be avoided only if we disable all reports (not
just the one in this thread), but it's probably not worth the
optimization.

This is all thread-local, with the exception of when we record another
thread's traceback.  To implement this, we clone the complete traceback
into the other thread's local allocator.  It should be fine because it
is only needed once, on abort.
